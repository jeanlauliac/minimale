%language "c++"
%require "3.0.4"
%define api.value.type variant
%define parse.trace
%define parse.error verbose

%token COMPONENT
%token DEFAULT
%token EXPORT
%token RETURN

%token <int> INT
%token <float> FLOAT
%token <std::string> IDENTIFIER
%token <std::string> XML_TEXT_FRAGMENT

%type <std::vector<minimale::statement_id>> statements
%type <minimale::statement_id> statement
%type <std::vector<minimale::component_statement_id>> component_statements
%type <minimale::component_statement_id> component_statement
%type <minimale::component_statement_id> component_function
%type <minimale::component_statement_id> component_field
%type <minimale::type_annotation_id> type_annotation
%type <std::vector<minimale::object_type_annotation_field>> object_field_annotations
%type <minimale::object_type_annotation_field> object_field_annotation
%type <std::vector<minimale::function_statement_id>> function_statements
%type <minimale::function_statement_id> function_statement

%param { minimale::store& st }
%start unit

%code requires {
  #include "../../../src/lib/unit.h"
  #include <vector>
}

%code {
  #include <cstdio>
  #include <iostream>

  int yylex(yy::parser::semantic_type* yylval, minimale::store& st);
  extern bool yyxmltext;
  void yyerror(const char *s);
}

%%
unit: statements { st.unit.statements = std::move($1); };

statements:
    statements statement { ($$ = std::move($1)).push_back($2); }
  | %empty {};

statement:
  EXPORT DEFAULT COMPONENT IDENTIFIER[name] '{'
    component_statements[statements]
  '}'
  { $$ = st.create_component($name, std::move($statements)); };

component_statements:
    component_statements component_statement
    { ($$ = std::move($1)).push_back($2); }
  | %empty {};

component_statement:
    component_function { $$ = $1; }
  | component_field { $$ = $1; };

component_function:
  IDENTIFIER[name] '(' ')' '{'
    function_statements[sts]
  '}'
  { $$ = st.create_component_function($name, std::move($sts)); };

component_field:
  IDENTIFIER[name] ':' type_annotation[type] ';'
  { $$ = st.create_component_field($name, $type); };

type_annotation:
    IDENTIFIER { $$ = st.create_literal_type_annotation($1); }
  | '{' object_field_annotations[fields] '}'
    { $$ = st.create_object_type_annotation(std::move($fields)); };

object_field_annotations:
    object_field_annotations object_field_annotation
    { ($$ = std::move($1)).push_back($2); }
  | %empty {};

object_field_annotation:
  IDENTIFIER[name] ':' type_annotation[type] ','
  { $$ = minimale::object_type_annotation_field($name, $type); };

function_statements:
    function_statements function_statement
    { ($$ = std::move($1)).push_back($2); }
  | %empty {};

function_statement:
  RETURN expression ';'
  { $$ = st.create_return_statement(); };

expression:
    '(' expression ')'
  | IDENTIFIER
  | expression '.' IDENTIFIER
  | xml_expression;
xml_expression: matched_xml_tag;
/* use http://www.gnu.org/software/bison/manual/bison.html#Lexical-Tie_002dins */
matched_xml_tag:
  '<' IDENTIFIER '>' { yyxmltext = true; }
  xml_text
  '<' { yyxmltext = false; } '/' IDENTIFIER '>';
xml_text:
    xml_text XML_TEXT_FRAGMENT
  | xml_text xml_interpolation
  | %empty;
xml_interpolation:
  '{' { yyxmltext = false; } expression '}' { yyxmltext = true; }
%%

void yy::parser::error(const std::string& m) {
  std::cerr << m << std::endl;
}
